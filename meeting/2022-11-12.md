# 2022-11-12

## Progress in Previous Week
Class design, Working flow design => Done

Define necessary functionalities for implementing flow => Done

Class implementation in high level => Done

gRPC ì˜ˆì œ ì½”ë“œ ì‘ì„± => Done

## Goal of the Week

gRPC ì ìš© => Master Slave êµ¬ì¡° êµ¬í˜„ ë° í†µì‹  í™•ì¸

gRPC test code ì‘ì„±

## Goal of the Week for each Member
ì†¡ìˆ˜ë¯¼: Dependencyí™•ì¸ ë° ë¹Œë“œ í™˜ê²½ êµ¬ì¶•

ì„ê²½ë¹ˆ: gRPC ì½”ë“œ ì‘ì„±

ì—¼ì¬í›„: gRPC ì½”ë“œ ì‘ì„± ë° ì‘ë™ specification

## Progress of this week
### Sumin Song
![fig1](./Figure/Sketch-2.jpg) <br>
![fig2](./Figure/Sketch-3.jpg) <br>
![fig3](./Figure/Sketch-4.png) <br>

### Kyungbin Lim
### gRPC

<aside>
ğŸ’¡ **[gRPC](https://grpc.io/)**ëŠ” êµ¬ê¸€ì—ì„œ ê°œë°œí•œ ìµœì‹  ì˜¤í”ˆ ì†ŒìŠ¤ ê³ ì„±ëŠ¥Â **RPC** í”„ë ˆì„ì›Œí¬ì´ë‹¤.

</aside>

<aside>
ğŸ’¡ **RPC** : Remote Procedure Callì˜ ì•½ìë¡œ ë³„ë„ì˜ ì›ê²© ì œì–´ë¥¼ ìœ„í•œ ì½”ë”© ì—†ì´ ë‹¤ë¥¸ ì£¼ì†Œ ê³µê°„ì—ì„œ í•¨ìˆ˜ë‚˜ í”„ë¡œì‹œì €ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆê²Œí•˜ëŠ” í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹  ê¸°ìˆ ì´ë‹¤.

</aside>

### Introduction to gRPC

[Introduction to gRPC](https://grpc.io/docs/what-is-grpc/introduction/)

### Overview

gRPCì—ì„œëŠ” í´ë¼ì´ì–¸íŠ¸ ì–´í”Œë¦¬ì¼€ì´ì…˜ì´ ì„œë²„ ì–´í”Œë¦¬ì¼€ì´ì…˜ì— ìˆëŠ” ë©”ì†Œë“œë¥¼ ë§ˆì¹˜ ìì‹ ì˜ ë¡œì»¬ ì˜¤ë¸Œì íŠ¸ì¸ ê²ƒì²˜ëŸ¼ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤. ì—¬ëŠ RPC ì‹œìŠ¤í…œê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ì„œë¹„ìŠ¤ ì •ì˜ ê°œë…ì— ê¸°ë°˜ì„ ë‘ê³  ìˆìœ¼ë©° parameterì™€ return íƒ€ì…ì„ ê°€ì§€ê³  ì›ê²©ìœ¼ë¡œ ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤. ì„œë²„ëŠ” ì´ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ê³  gRPCì„œë²„ë¥¼ ì‹¤í–‰í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ í˜¸ì¶œì„ ì²˜ë¦¬í•œë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” ì„œë²„ì™€ ë™ì¼í•œ ë©”ì†Œë“œì„ ì œê³µí•˜ëŠ” stubì„ ê°€ì§€ê³  ìˆë‹¤.

![Untitled](./Figure/Untitled.png)

### Protocol Buffers

êµ¬ê¸€ì—ì„œ ì˜¤í”ˆì†ŒìŠ¤ë¡œ ê³µê°œí•œ ì–¸ì–´, êµ¬ì¡°í™”(structured)ëœ ë°ì´í„°ë¥¼ ì§ë ¬í™”(serialization) í•˜ëŠ” ë°©ì‹.

<aside>
ğŸ’¡ **ì§ë ¬í™”(Serialization)** : ë°ì´í„° í‘œí˜„ì€ ê²°êµ­ ë¹„íŠ¸ì™€ ë°”ì´íŠ¸ë¡œ ì´ë£¨ì–´ì§. ë°ì´í„°ë¥¼ ë°”ì´íŠ¸ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“œëŠ” ê²ƒë„ ì§ë ¬í™”, JSONì´ë‚˜ XMLê³¼ ê°™ì€ ì¼ì •í•œ í‘œí˜„ í˜•ì‹ìœ¼ë¡œ ë§Œë“œëŠ” ê²ƒë„ ì§ë ¬í™”. í”„ë¡œí† ì½œ ë²„í¼ë„ ë°ì´í„°ë¥¼ ì§ë ¬í™”ì‹œí‚¤ëŠ” í¬ë§· ì¤‘ í•˜ë‚˜.

</aside>

í”„ë¡œí† ì½œ ë²„í¼ëŠ” ë°ì´í„°ì˜ í¬ê¸°ê°€ ì‘ì•„ ê°™ì€ ì‹œê°„ì— ë” ë§ì€ ë°ì´í„°ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆë‹¤. ë˜ ë³„ë„ì˜ íŒŒì‹±ì´ í•„ìš”ê°€ ì—†ë‹¤. í•˜ì§€ë§Œ ì¸ê°„ì´ ì½ê¸° ë¶ˆí¸í•˜ë©° protoíŒŒì¼ì´ ìˆì–´ì•¼ ì½ì„ ìˆ˜ ìˆë‹¤ëŠ” ë‹¨ì ì´ ìˆë‹¤. ì¦‰ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ê°€ proto íŒŒì¼ì´ ìˆì–´ì•¼ í•˜ë¯€ë¡œ ë‚´ë¶€ ì„œë¹„ìŠ¤ê°„ ë°ì´í„° êµí™˜ì—ì„œ ì£¼ë¡œ ì“°ì¸ë‹¤.

### JSON(JavaScript Object Notation)

- ë°ì´í„°ë¥¼ ì €ì¥í•˜ê±°ë‚˜ ì „ì†¡í•  ë•Œ ë§ì´ ì‚¬ìš©ë˜ëŠ”Â **ê²½ëŸ‰ì˜ DATA êµí™˜ í˜•ì‹**, ì¦‰ ê°ì²´ë¥¼ ë§Œë“¤ ë•Œ ì‚¬ìš©í•˜ëŠ” í‘œí˜„ì‹ì„ ì˜ë¯¸í•œë‹¤.
- JSONì€ ë°ì´í„° í¬ë§·ì¼ ë¿ì´ë©° ì–´ë– í•œ í†µì‹  ë°©ë²•ë„, í”„ë¡œê·¸ë˜ë° ë¬¸ë²•ë„ ì•„ë‹Œ ë‹¨ìˆœíˆ ë°ì´í„°ë¥¼ í‘œì‹œí•˜ëŠ” í‘œí˜„ ë°©ë²•ì¼ ë¿ì´ë‹¤.

```python
{
  "employees": [
    {
      "name": "Surim",
      "lastName": "Son"
    },
    {
      "name": "Someone",
      "lastName": "Huh"
    },
    {
      "name": "Someone else",
      "lastName": "Kim"
    } 
  ]
}
```

### Working with Protocol Buffers

ê¸°ë³¸ì ìœ¼ë¡œ gRPCëŠ” êµ¬ì¡°í™”ëœ ë°ì´í„°ë¥¼ ì§ë ¬í™”í•˜ê¸° ìœ„í•´ êµ¬ê¸€ì˜ ì˜¤í”ˆ ì†ŒìŠ¤ ë©”ì»¤ë‹ˆì¦˜ì¸ í”„ë¡œí† ì½œ ë²„í¼ë¥¼ ì‚¬ìš©í•œë‹¤.

í”„ë¡œí† ì½œ ë²„í¼ë¡œ ì‘ì—…í•  ë•Œ ë¨¼ì € í”„ë¡œí† ì½œ íŒŒì¼ì—ì„œ ì§ë ¬í™”í•  ë°ì´í„°ì˜ êµ¬ì¡°ë¥¼ ì •ì˜í•œë‹¤. ì´ê²ƒì€ .proto í™•ì¥ìë¥¼ ê°€ì§„ ì¼ë°˜ í…ìŠ¤íŠ¸ íŒŒì¼.

```java
message Person {
  string name = 1;
  int32 id = 2;
  bool has_ponycopter = 3;
}
```

gRPCì—ì„œ ì‚¬ìš©í•  protobufì˜ ëŒ€ëµì ì¸ ëª¨ìŠµì€ ì•„ë˜ì™€ ê°™ë‹¤.

```java
syntax = "proto3";

package ecommerce;

service ProductInfo {
    rpc addProduct(Product) returns (ProductID);
    rpc getProduct(ProductID) returns (Product);
}

message Product {
    string id = 1;
    string name = 2;
    string description = 3;
    float price = 4;
}

message ProductID {
    string value = 1;
}
```

ìë°” ê¸°ì¤€ìœ¼ë¡œÂ `service`ëŠ”Â `interface`ì— ìˆëŠ” ì¶”ìƒë©”ì„œë“œ ë¼ê³  ìƒê°í•˜ë©´ í¸í•˜ê³ Â `message`ëŠ” Dto, ê°’ ê°ì²´ë¼ê³  ìƒê°í•˜ë©´ í¸í•˜ë‹¤.

ì´ì œ ì‘ì„±í•œ ì´ .protoì„ ê°ê° ì–¸ì–´ì— ë§ëŠ” protocë¥¼ ì‚¬ìš©í•´ì„œ ì»´íŒŒì¼í•œë’¤ì— ì„œë²„ì¸¡ì—ì„œëŠ” ë¯¸ë¦¬ ì •ì˜í•œÂ `service` ì˜ êµ¬í˜„ì²´ë¥¼ ì‘ì„±í•˜ê³  í´ë¼ì´ì–¸íŠ¸ì—ì„œëŠ” ì œê³µë˜ëŠ”Â `service`ì˜ stub ê°ì²´ë¥¼ í™œìš©í•´ì„œ í†µì‹ í•˜ë©´ ëœë‹¤.

### gRPC Examples

### gRPC Quick start

[Quick start](https://grpc.io/docs/languages/java/quickstart/)

ìœ„ ë§í¬ì—ì„œ gRPC example í”„ë¡œê·¸ë¨ì„ ë‹¤ìš´ë°›ì•„ ì»´íŒŒì¼í•˜ê³  ì‹¤í–‰í•˜ì˜€ë‹¤.

![Untitled](./Figure/Untitled%201.png)

![Untitled](./Figure/Untitled%202.png)

## Update the gRPC service

gRPC ì„œë¹„ìŠ¤ëŠ” í”„ë¡œí† ì½œ ë²„í¼ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ê³  ìˆê¸° ë•Œë¬¸ì—, ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ ëª¨ë‘ proto íŒŒì¼ì— ì½”ë“œë¥¼ ì‘ì„±í•¨ìœ¼ë¡œì¨ ì„œë¹„ìŠ¤ë¥¼ ë””íŒŒì¸í•  ìˆ˜ ìˆë‹¤.

```java
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
```

src/main/proto ë””ë ‰í† ë¦¬ì— proto íŒŒì¼ë“¤ ì¡´ì¬. ì—¬ê¸°ì—ì„œ ì„œë¹„ìŠ¤ ë””íŒŒì¸.

í”„ë¡œê·¸ë¨ ë¹Œë“œ í›„ src/main/java/io/grpc/examplesì—ì„œ ì„œë²„ìš© ìë°”íŒŒì¼ê³¼ í´ë¼ì´ì–¸íŠ¸ìš© ìë°”íŒŒì¼ì— ê°ê° ì½”ë“œ ì‚½ì….

**ì„œë²„ìš© ìë°”íŒŒì¼**

```java
private class GreeterImpl extends GreeterGrpc.GreeterImplBase {

  @Override
  public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {
    HelloReply reply = HelloReply.newBuilder().setMessage("Hello " + req.getName()).build();
    responseObserver.onNext(reply);
    responseObserver.onCompleted();
  }

  @Override
  public void sayHelloAgain(HelloRequest req, StreamObserver<HelloReply> responseObserver) {
    HelloReply reply = HelloReply.newBuilder().setMessage("Hello again " + req.getName()).build();
    responseObserver.onNext(reply);
    responseObserver.onCompleted();
  }
}
```

**í´ë¼ì´ì–¸íŠ¸ìš© ìë°”íŒŒì¼**

```java
public void greet(String name) {
  logger.info("Will try to greet " + name + " ...");
  HelloRequest request = HelloRequest.newBuilder().setName(name).build();
  HelloReply response;
  try {
    response = blockingStub.sayHello(request);
  } catch (StatusRuntimeException e) {
    logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
    return;
  }
  logger.info("Greeting: " + response.getMessage());
  try {
    response = blockingStub.sayHelloAgain(request);
  } catch (StatusRuntimeException e) {
    logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
    return;
  }
  logger.info("Greeting: " + response.getMessage());
}
```

**ì‹¤í–‰í™”ë©´**

![Untitled](./Figure/Untitled%203.png)

![Untitled](./Figure/Untitled%204.png)

### gRPC basic tutorial

### Defining the service

proto íŒŒì¼ì—ì„œ ì„œë¹„ìŠ¤ ë””íŒŒì¸. ì´ë•Œ ìë°” íŒ¨í‚¤ì§€(ìë°” í´ë˜ìŠ¤ ëª¨ìŒ)ë¥¼ ëª…ì‹œí•  ìˆ˜ ìˆë‹¤.

```java
option java_package = "io.grpc.examples.routeguide";
```

serviceë¥¼ í†µí•´ ì„œë¹„ìŠ¤ë¥¼ ë””íŒŒì¸í•  ìˆ˜ ìˆë‹¤.

```java
service RouteGuide {
   ...
}
```

ì„œë¹„ìŠ¤ ë°í”¼ë‹ˆì…˜ ì•ˆì—ì„œ rpc ë©”ì†Œë“œë¥¼ ì •ì˜í•œë‹¤. ì´ë•Œ requestì™€ response íƒ€ì…ì„ ì§€ì •í•œë‹¤. gRPCì—ì„œëŠ” ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ì— ë”°ë¼ 4ê°€ì§€ rpc í˜•íƒœë¥¼ ì •ì˜í•˜ê³  ìˆë‹¤.

```java
// Obtains the feature at a given position.
rpc GetFeature(Point) returns (Feature) {}
```

proto íŒŒì¼ì—ì„œ protocol buffer message íƒ€ì…ì„ ì •ì˜í•œë‹¤. ìœ„ rpc ì˜ˆì‹œì—ì„œ Pointë¼ëŠ” íƒ€ì…ì„ ì•„ë˜ì™€ ê°™ì´ ì •ì˜í•œë‹¤.

```java
// Points are represented as latitude-longitude pairs in the E7 representation
// (degrees multiplied by 10**7 and rounded to the nearest integer).
// Latitudes should be in the range +/- 90 degrees and longitude should be in
// the range +/- 180 degrees (inclusive).
message Point {
  int32 latitude = 1;
  int32 longitude = 2;
}
```

- **AÂ *simple RPC** :* where the client sends a request to the server using the stub and waits for a response to come back, just like a normal function call.
- **AÂ *server-side streaming RPC :*** where the client sends a request to the server and gets a stream to read a sequence of messages back. The client reads from the returned stream until there are no more messages. As you can see in our example, you specify a server-side streaming method by placing theÂ `stream`
Â keyword before theÂ *response*
Â type.
- **AÂ *client-side streaming RPC :*** where the client writes a sequence of messages and sends them to the server, again using a provided stream. Once the client has finished writing the messages, it waits for the server to read them all and return its response. You specify a client-side streaming method by placing theÂ `stream`
Â keyword before theÂ *request*
Â type.
- **AÂ *bidirectional streaming RPC :*** where both sides send a sequence of messages using a read-write stream. The two streams operate independently, so clients and servers can read and write in whatever order they like: for example, the server could wait to receive all the client messages before writing its responses, or it could alternately read a message then write a message, or some other combination of reads and writes. The order of messages in each stream is preserved. You specify this type of method by placing theÂ `stream`
Â keyword before both the request and the response.

### Generation client and server code

protocì´ë¼ëŠ” í”„ë¡œí† ì½œ ë²„í¼ ì»´íŒŒì¼ëŸ¬ ì‚¬ìš©. 

### Creating the server

1. service ë°í”¼ë‹ˆì…˜ìœ¼ë¡œë¶€í„° ì„œë¹„ìŠ¤ ë² ì´ìŠ¤ í´ë˜ìŠ¤ ì˜¤ë²„ë¼ì´ë”©í•˜ì—¬ actual work ë§Œë“¤ê¸°
2. gRPCì„œë²„ë¥¼ ì‹¤í–‰í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ì˜ ë¦¬í€˜ìŠ¤íŠ¸ ë“£ê³  ì„œë¹„ìŠ¤ responseí•˜ê¸°

```java
@Override
public void getFeature(Point request, StreamObserver<Feature> responseObserver) {
  responseObserver.onNext(checkFeature(request));
  responseObserver.onCompleted();
}
```

getFeature() ë©”ì†Œë“œëŠ” ë‘ê°œì˜ íŒŒë¼ë¯¸í„°ë¥¼ ê°€ì§„ë‹¤. pointëŠ” í´ë¼ì´ì–¸íŠ¸ì˜ requestì´ë©° StreamObserver<Feature>ëŠ” response observerì´ë©° ì„œë²„ê°€ responseë¥¼ callí• ë•Œ ì‚¬ìš©í•˜ëŠ” íŠ¹ë³„í•œ ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.

responseObserver.onNext()ë¥¼ í†µí•´ ë¦¬í„´ì„ í•˜ê³ , responseObserver.onCompleted()ë¥¼ í†µí•´ RPCê°€ ëë‚¬ìŒì„ ëª…ì‹œí•œë‹¤.

### Starting the server

ì„œë²„ì—ì„œ í•„ìš”í•œ ë©”ì†Œë“œë¥¼ ì „ë¶€ êµ¬í˜„í–ˆë‹¤ë©´, gRPCì„œë²„ë¥¼ êµ¬ë™í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ê°€ ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í•´ì•¼í•œë‹¤. 

```java
public RouteGuideServer(int port, URL featureFile) throws IOException {
  this(ServerBuilder.forPort(port), port, RouteGuideUtil.parseFeatures(featureFile));
}

/** Create a RouteGuide server using serverBuilder as a base and features as data. */
public RouteGuideServer(ServerBuilder<?> serverBuilder, int port, Collection<Feature> features) {
  this.port = port;
  server = serverBuilder.addService(new RouteGuideService(features))
      .build();
}
...
public void start() throws IOException {
  server.start();
  logger.info("Server started, listening on " + port);
 ...
}
```

### Creating the client

ì„œë¹„ìŠ¤ ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•˜ê¸° ìœ„í•´ì„œëŠ” stubë¼ëŠ” ê²ƒì„ ë§Œë“¤ì–´ì•¼ í•œë‹¤. 

stubë¥¼ ìœ„í•œ gRPC ì±„ë„ì„ ë§Œë“¤ì–´ ì„œë²„ ì£¼ì†Œì™€ í¬íŠ¸ë¥¼ ëª…ì‹œí•œë‹¤.

```java
public RouteGuideClient(String host, int port) {
  this(ManagedChannelBuilder.forAddress(host, port).usePlaintext());
}

/** Construct client for accessing RouteGuide server using the existing channel. */
public RouteGuideClient(ManagedChannelBuilder<?> channelBuilder) {
  channel = channelBuilder.build();
  blockingStub = RouteGuideGrpc.newBlockingStub(channel);
  asyncStub = RouteGuideGrpc.newStub(channel);
}
```

ì´ì œ ìœ„ì—ì„œ ëª…ì‹œí•œ ì±„ë„ì„ ì´ìš©í•´ newStubì™€ newBlockingStub ë©”ì†Œë“œë¥¼ ê°€ì§€ê³  stubë¥¼ ì •ì˜í•œë‹¤.

```java
blockingStub = RouteGuideGrpc.newBlockingStub(channel);
asyncStub = RouteGuideGrpc.newStub(channel);
```

ì´ì œ ë„¤ê°€ì§€ ìœ í˜• ì¤‘ ì•Œë§ê²Œ ì„œë¹„ìŠ¤ ë©”ì†Œë“œë¥¼ êµ¬í˜„í•˜ë©´ ëœë‹¤.

```java
Point request = Point.newBuilder().setLatitude(lat).setLongitude(lon).build();
Feature feature;
try {
  feature = blockingStub.getFeature(request);
} catch (StatusRuntimeException e) {
  logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
  return;
}
```
